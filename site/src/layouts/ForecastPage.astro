---
import MainLayout from './MainLayout.astro';
import Navbar from '../components/Navbar.astro';

const { data } = Astro.props;
const history = data.history ?? [];
const forecast = data.forecast ?? [];
const backtest = data.backtest ?? [];
const backtestPoints = data.backtest_points ?? [];

const runTitle = data?.meta?.slug || data.request?.run_name_root || (data.request?.series_names || []).join(', ') || 'series';

const seriesIds = [...new Set([
  ...history.map((r) => r.unique_id),
  ...forecast.map((r) => r.unique_id),
  ...backtestPoints.map((r) => r.unique_id),
])];

const parseDs = (v) => {
  const s = String(v ?? '');
  const normalized = s.includes('T') ? s : s.replace(' ', 'T');
  const d = new Date(normalized);
  return Number.isNaN(d.getTime()) ? null : d;
};

const buildChartState = (actualRows, forecastRows, h = 320) => {
  const aRows = actualRows
    .map((r) => ({ ...r, iso: parseDs(r.ds)?.toISOString() }))
    .filter((r) => r.iso);
  const fRows = forecastRows
    .map((r) => ({ ...r, iso: parseDs(r.ds)?.toISOString() }))
    .filter((r) => r.iso);

  const labels = [...new Set([...aRows.map((r) => r.iso), ...fRows.map((r) => r.iso)])].sort();

  const actualValues = labels.map((l) => {
    const row = aRows.find((r) => r.iso === l);
    return row ? Number(row.y) : null;
  });

  const modelNames = [...new Set(fRows.map((r) => r.model))];
  const modelSeries = modelNames.map((model) => ({
    model,
    values: labels.map((l) => {
      const row = fRows.find((r) => r.iso === l && r.model === model);
      return row ? Number(row.yhat) : null;
    }),
  }));

  const allY = [
    ...actualValues.filter((v) => Number.isFinite(v)),
    ...modelSeries.flatMap((s) => s.values.filter((v) => Number.isFinite(v))),
  ];

  const yMin = allY.length ? Math.min(...allY) : 0;
  const yMax = allY.length ? Math.max(...allY) : 1;

  const W = 920;
  const H = h;
  const PAD = { t: 18, r: 18, b: 40, l: 44 };
  const innerW = W - PAD.l - PAD.r;
  const innerH = H - PAD.t - PAD.b;

  const xFor = (i) => PAD.l + (labels.length <= 1 ? 0 : (i / (labels.length - 1)) * innerW);
  const yFor = (v) => {
    if (!Number.isFinite(v)) return null;
    const range = yMax - yMin || 1;
    return PAD.t + (1 - (v - yMin) / range) * innerH;
  };

  const toPath = (arr) => {
    let d = '';
    arr.forEach((v, i) => {
      const y = yFor(v);
      if (y === null) return;
      const x = xFor(i);
      d += d ? ` L ${x} ${y}` : `M ${x} ${y}`;
    });
    return d;
  };

  const actualPath = toPath(actualValues);
  const colors = ['#ef4444', '#22c55e', '#a855f7', '#f97316', '#14b8a6'];

  return { W, H, PAD, innerW, innerH, labels, actualValues, actualPath, modelSeries, colors, xFor, yFor, yMin, yMax };
};

const getMainChart = (sid) => {
  const hRows = history.filter((r) => r.unique_id === sid);
  const fRows = forecast.filter((r) => r.unique_id === sid);
  return buildChartState(hRows, fRows, 320);
};

const backtestBySeries = seriesIds.map((sid) => {
  const scoreRows = backtest.filter((r) => r.unique_id === sid);
  const windowIds = [...new Set(scoreRows.map((r) => Number(r.window)).filter(Number.isFinite))].sort((a, b) => a - b);

  const windows = windowIds.map((w) => {
    const pts = backtestPoints.filter((p) => p.unique_id === sid && Number(p.window) === w);
    const actualMap = new Map();
    pts.forEach((p) => {
      const key = String(p.ds);
      if (!actualMap.has(key)) actualMap.set(key, { ds: p.ds, y: p.y });
    });
    const actualRows = [...actualMap.values()];
    const forecastRows = pts.map((p) => ({ ds: p.ds, model: p.model, yhat: p.yhat }));
    const chart = buildChartState(actualRows, forecastRows, 260);

    const scores = scoreRows.filter((r) => Number(r.window) === w).sort((a, b) => String(a.model).localeCompare(String(b.model)));
    return { window: w, chart, scores };
  });

  return { sid, windows };
});
---
<MainLayout title={`Forecast ${runTitle}`}>
  <style is:global>
    html { scroll-behavior: smooth; }
  </style>

  <Navbar />

  <div class="mt-4 grid gap-4 lg:grid-cols-[220px_minmax(0,1fr)]">
    <aside class="lg:sticky lg:top-6 h-max rounded-xl border border-slate-700 bg-slate-900/60 p-3">
      <h2 class="text-xs uppercase tracking-wider text-slate-400">Navigate</h2>
      <nav class="mt-2 space-y-1 text-sm">
        <a href="#top" class="block rounded px-2 py-1 text-slate-300 hover:bg-slate-800">Overview</a>
        {seriesIds.map((sid) => (
          <a href={`#series-${sid}`} class="block rounded px-2 py-1 text-slate-300 hover:bg-slate-800">Series: {sid}</a>
        ))}
        <a href="#payload" class="block rounded px-2 py-1 text-slate-300 hover:bg-slate-800">Payload</a>
      </nav>
    </aside>

    <section id="top" class="space-y-4">
      <h1 class="text-2xl font-bold">Forecast: {runTitle}</h1>
      <p class="text-slate-400">Backend: {data.backend} · Granularity: {data.request.granularity} · Horizon: {data.request.horizon}</p>
      {data?.meta?.github?.run_url && <p class="text-sm"><a href={data.meta.github.run_url} target="_blank" rel="noreferrer" class="text-sky-300">GitHub action run ↗</a></p>}

      {seriesIds.map((sid) => {
        const chart = getMainChart(sid);
        const back = backtestBySeries.find((x) => x.sid === sid);
        return (
          <article id={`series-${sid}`} class="rounded-xl border border-slate-700 bg-slate-900/70 p-4 scroll-mt-8">
            <h2 class="font-semibold mb-2">Series: {sid}</h2>

            <h3 class="text-sm text-slate-300 mb-2">Main forecast</h3>
            <div class="overflow-x-auto">
              <svg viewBox={`0 0 ${chart.W} ${chart.H}`} class="min-w-[760px] w-full rounded bg-slate-950">
                <rect x={chart.PAD.l} y={chart.PAD.t} width={chart.innerW} height={chart.innerH} fill="none" stroke="#1e293b" />
                {Array.from({ length: 5 }).map((_, i) => {
                  const y = chart.PAD.t + (i / 4) * chart.innerH;
                  const val = (chart.yMax - ((i / 4) * (chart.yMax - chart.yMin))).toFixed(1);
                  return (
                    <g>
                      <line x1={chart.PAD.l} y1={y} x2={chart.W - chart.PAD.r} y2={y} stroke="#0f172a" />
                      <text x="6" y={y + 4} font-size="11" fill="#94a3b8">{val}</text>
                    </g>
                  );
                })}

                {chart.actualPath && <path d={chart.actualPath} fill="none" stroke="#38bdf8" stroke-width="2" />}
                {chart.actualValues.map((v, i) => {
                  const y = chart.yFor(v);
                  if (y === null) return null;
                  return <circle cx={chart.xFor(i)} cy={y} r="2.8" fill="#38bdf8" />;
                })}

                {chart.modelSeries.map((s, idx) => {
                  const d = (() => {
                    let p = '';
                    s.values.forEach((v, i) => {
                      const y = chart.yFor(v);
                      if (y === null) return;
                      const x = chart.xFor(i);
                      p += p ? ` L ${x} ${y}` : `M ${x} ${y}`;
                    });
                    return p;
                  })();

                  return (
                    <>
                      {d && <path d={d} fill="none" stroke={chart.colors[idx % chart.colors.length]} stroke-width="2" stroke-dasharray="6 4" />}
                      {s.values.map((v, i) => {
                        const y = chart.yFor(v);
                        if (y === null) return null;
                        return <circle cx={chart.xFor(i)} cy={y} r="2.5" fill={chart.colors[idx % chart.colors.length]} />;
                      })}
                    </>
                  );
                })}
              </svg>
            </div>

            <details class="mt-4 rounded-lg border border-slate-700 bg-slate-950/40 p-3">
              <summary class="cursor-pointer font-semibold text-sm">Backfill testing + accuracies</summary>
              {back && back.windows.length > 0 ? (
                <div class="mt-3 space-y-4">
                  {back.windows.map((wObj) => {
                    const firstScore = wObj.scores?.[0];
                    const holdoutStart = firstScore ? String(firstScore.holdout_start) : 'n/a';
                    const holdoutEnd = firstScore ? String(firstScore.holdout_end) : 'n/a';
                    return (
                      <details class="rounded border border-slate-700 p-3" open>
                        <summary class="cursor-pointer text-xs text-slate-300 mb-2 font-semibold">Backtest window {wObj.window} · {holdoutStart} → {holdoutEnd}</summary>
                        <div class="overflow-x-auto mt-2">
                          <svg viewBox={`0 0 ${wObj.chart.W} ${wObj.chart.H}`} class="min-w-[720px] w-full rounded bg-slate-950">
                            <rect x={wObj.chart.PAD.l} y={wObj.chart.PAD.t} width={wObj.chart.innerW} height={wObj.chart.innerH} fill="none" stroke="#1e293b" />

                            {wObj.chart.actualPath && <path d={wObj.chart.actualPath} fill="none" stroke="#38bdf8" stroke-width="2" />}
                            {wObj.chart.actualValues.map((v, i) => {
                              const y = wObj.chart.yFor(v);
                              if (y === null) return null;
                              return <circle cx={wObj.chart.xFor(i)} cy={y} r="2.7" fill="#38bdf8" />;
                            })}

                            {wObj.chart.modelSeries.map((s, idx) => {
                              const d = (() => {
                                let p = '';
                                s.values.forEach((v, i) => {
                                  const y = wObj.chart.yFor(v);
                                  if (y === null) return;
                                  const x = wObj.chart.xFor(i);
                                  p += p ? ` L ${x} ${y}` : `M ${x} ${y}`;
                                });
                                return p;
                              })();

                              return (
                                <>
                                  {d && <path d={d} fill="none" stroke={wObj.chart.colors[idx % wObj.chart.colors.length]} stroke-width="2" stroke-dasharray="6 4" />}
                                  {s.values.map((v, i) => {
                                    const y = wObj.chart.yFor(v);
                                    if (y === null) return null;
                                    return <circle cx={wObj.chart.xFor(i)} cy={y} r="2.4" fill={wObj.chart.colors[idx % wObj.chart.colors.length]} />;
                                  })}
                                </>
                              );
                            })}
                          </svg>
                        </div>
                      </details>
                    );
                  })}
                </div>
              ) : (
                <p class="mt-2 text-sm text-slate-400">No backtest rows for this series yet (need more history or windows).</p>
              )}
            </details>
          </article>
        );
      })}

      <details id="payload" class="rounded-xl border border-slate-700 bg-slate-900/70 p-4 scroll-mt-8">
        <summary class="cursor-pointer font-semibold">Payload</summary>
        <pre class="mt-2 overflow-auto rounded bg-slate-950 p-3 text-xs">{JSON.stringify(data.request, null, 2)}</pre>
      </details>
    </section>
  </div>
</MainLayout>
